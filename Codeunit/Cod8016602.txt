OBJECT Codeunit 8016602 Tools Management
{
  OBJECT-PROPERTIES
  {
    Date=25/04/14;
    Time=12:30:30;
    Modified=Yes;
    Version List=ISA6.00,IMH6.01,GED;
  }
  PROPERTIES
  {
    OnRun=BEGIN
          END;

  }
  CODE
  {
    VAR
      Text000@8016608 : TextConst 'ENU=%1 is not an ASCII character.;FRA=%1 n''est pas un caractäre ASCII.';
      Text001@8016607 : TextConst 'ENU=You must specify a filename.;FRA=Vous devez saisir une valeur pour %1.';
      Text002@8016606 : TextConst 'ENU=You must enter a value for %1.;FRA=Vous devez saisir une valeur pour %1.';
      Text003@8016605 : TextConst 'ENU=%1 is not a valid value for %2.;FRA=%1 n''est pas une valeur valide pour %2.';
      Text004@8016604 : TextConst 'ENU=The %1 field must not contain spaces, commas or periods.;FRA=Le champ %1 ne doit pas contenir d''espaces, de virgules ou de pÇriodes.';
      FromControlChar@1100281000 : Text[31];
      ToControlChar@1100281001 : Text[31];
      ANSIText@1100281002 : Text[80];
      ASCIIText@1100281003 : Text[80];
      AE@8016601 : Char;
      UE@8016600 : Char;
      OE@8016609 : Char;

    PROCEDURE GetEOL@1100281020() rValue : Text[2];
    BEGIN
      rValue[1] := 13;
      rValue[2] := 10;
    END;

    PROCEDURE FindLookupAccount@8016600(Type@8016600 : 'G/L Account,Customer,Vendor,Bank Account,Fixed Asset,Contact';Text@8016605 : Text[1024];RespCenter@8016608 : Code[20]) : Text[1024];
    VAR
      GLAcc@8016601 : Record 15;
      Vend@8016603 : Record 23;
      Cust@8016602 : Record 18;
      FA@8016604 : Record 5600;
      BankAcc@8016606 : Record 270;
      Cont@8016607 : Record 5050;
    BEGIN
      IF Text <> '' THEN
        CASE Type OF
          Type::"G/L Account" : BEGIN
            IF NOT GLAcc.GET(Text) THEN BEGIN
              GLAcc.SETCURRENTKEY("Search Name");
              GLAcc.SETFILTER("No.",'%1','*' + Text + '*');
              GLAcc.SETRANGE("Account Type",GLAcc."Account Type"::Posting);
              IF FORM.RUNMODAL(FORM::"G/L Account List",GLAcc) = ACTION::LookupOK THEN
                EXIT(GLAcc."No.")
              ELSE
                EXIT('');
            END;
          END;
          Type::Customer : BEGIN
            IF NOT Cust.GET(Text) THEN BEGIN
              Cust.SETCURRENTKEY("Search Name");
              Cust.SETFILTER("Search Name",'%1','*' + Text + '*');
              IF FORM.RUNMODAL(FORM::"Customer List",Cust) = ACTION::LookupOK THEN
                EXIT(Cust."No.")
              ELSE
                EXIT('');
            END;
          END;
          Type::Vendor : BEGIN
            IF NOT Vend.GET(Text) THEN BEGIN
              Vend.SETCURRENTKEY("Search Name");
              Vend.SETFILTER("Search Name",'%1','*' + Text + '*');
              IF FORM.RUNMODAL(FORM::"Vendor List",Vend) = ACTION::LookupOK THEN
                EXIT(Vend."No.")
              ELSE
                EXIT('');
            END;
          END;
          Type::"Bank Account": BEGIN
            IF NOT BankAcc.GET(Text) THEN BEGIN
              BankAcc.SETCURRENTKEY("Search Name");
              BankAcc.SETFILTER("Search Name",'%1','*' + Text + '*');
              IF FORM.RUNMODAL(FORM::"Bank Account List",BankAcc) = ACTION::LookupOK THEN
                EXIT(BankAcc."No.")
              ELSE
                EXIT('');
            END;
          END;
          Type::"Fixed Asset" : BEGIN
            IF NOT FA.GET(Text) THEN BEGIN
              FA.SETCURRENTKEY("Search Description");
              FA.SETFILTER("Search Description",'%1','*' + Text + '*');
              IF FORM.RUNMODAL(FORM::"Fixed Asset List",FA) = ACTION::LookupOK THEN
                EXIT(FA."No.")
              ELSE
                EXIT('');
            END;
          END;
          Type::Contact : BEGIN
            IF NOT Cont.GET(Text) THEN BEGIN
              Cont.SETCURRENTKEY("Search Name");
              Cont.SETFILTER("Search Name",'%1','*' + Text + '*');
              Cont.SETRANGE(Type,Cont.Type::Company);
              IF FORM.RUNMODAL(FORM::"Contact List",Cont) = ACTION::LookupOK THEN
                EXIT(Cont."No.")
              ELSE
                EXIT('');
            END;
          END;
        END;

      EXIT(Text);
    END;

    PROCEDURE FindLookupType@8016601(Type@8016600 : ' ,Account (G/L),Item,Resource,Fixed Asset,Charge (Item)';Text@8016605 : Text[1024]) : Text[1024];
    VAR
      Item@8016601 : Record 27;
      Res@8016603 : Record 156;
      GLAcc@8016602 : Record 15;
      FA@8016604 : Record 5600;
      StandardText@8016606 : Record 7;
    BEGIN
      IF Text <> '' THEN
        CASE Type OF
          Type::" ": BEGIN
            IF NOT StandardText.GET(COPYSTR(Text,1,10)) THEN BEGIN
              StandardText.SETFILTER(Description,'*' + Text + '*');
              IF FORM.RUNMODAL(FORM::"Standard Text Codes",StandardText) = ACTION::LookupOK THEN
                EXIT(StandardText.Code)
              ELSE
                EXIT('');
            END;
          END;
          Type::"Account (G/L)" : BEGIN
            IF NOT GLAcc.GET(Text) THEN BEGIN
              GLAcc.SETCURRENTKEY("Search Name");
              GLAcc.SETFILTER("No.",'%1','*' + Text + '*');
              GLAcc.SETRANGE("Account Type",GLAcc."Account Type"::Posting);
              IF FORM.RUNMODAL(FORM::"G/L Account List",GLAcc) = ACTION::LookupOK THEN
                EXIT(GLAcc."No.")
              ELSE
                EXIT('');
            END;
          END;
          Type::Item : BEGIN
            IF NOT Item.GET(Text) THEN BEGIN
              Item.SETCURRENTKEY("Search Description");
              Item.SETFILTER("Search Description",'*' + Text + '*');
              IF FORM.RUNMODAL(FORM::"Item List",Item) = ACTION::LookupOK THEN
                EXIT(Item."No.")
              ELSE
                EXIT('');
            END;
          END;
          Type::Resource : BEGIN
            IF NOT Res.GET(Text) THEN BEGIN
              Res.SETCURRENTKEY("Search Name");
              Res.SETFILTER("Search Name",'%1','*' + Text + '*');
              IF FORM.RUNMODAL(FORM::"Resource List",Res) = ACTION::LookupOK THEN
                EXIT(Res."No.")
              ELSE
                EXIT('');
            END;
          END;
          Type::"Fixed Asset" : BEGIN
            IF NOT FA.GET(Text) THEN BEGIN
              FA.SETCURRENTKEY("Search Description");
              FA.SETFILTER("Search Description",'%1','*' + Text + '*');
              IF FORM.RUNMODAL(FORM::"Fixed Asset List",FA) = ACTION::LookupOK THEN
                EXIT(FA."No.")
              ELSE
                EXIT('');
            END;
          END;
        END;

      EXIT(Text);
    END;

    PROCEDURE ReplaceControlCaracter@1100281009(pText@1100281000 : Text[1024]) rValue : Text[1024];
    VAR
      i@1100281002 : Integer;
    BEGIN
      // IMH11
      rValue := '';

      IF STRLEN(FromControlChar) = 0 THEN BEGIN
        FOR i := 1 TO 31 DO BEGIN
          FromControlChar[i] := i;
          ToControlChar += ' ';
        END;
      END;

      EXIT(CONVERTSTR(pText,FromControlChar,ToControlChar));
    END;

    PROCEDURE Ansi2Ascii@8016602(_Text@8016600 : Text[1024]) : Text[1024];
    VAR
      lAsciiStr@1100281001 : Text[30];
      lAnsiStr@1100281000 : Text[30];
    BEGIN
      lAsciiStr := 'ÑîÅéôöÇàäÉÖáì¯';
      AE := 196;
      UE := 220;
      OE := 244;
      lAnsiStr := '‰ˆ¸' + FORMAT(AE) + '÷' + FORMAT(UE) + 'ÈÍË‚‡Á' + FORMAT(OE) +'∞';

      EXIT(CONVERTSTR(_Text,lAnsiStr,lAsciiStr));
    END;

    PROCEDURE Ascii2Ansi@8016603(_Text@8016600 : Text[250]) : Text[250];
    VAR
      lAsciiStr@1100281001 : Text[30];
      lAnsiStr@1100281000 : Text[30];
    BEGIN
      lAsciiStr := 'ÑîÅéôöÇàäÉÖáì';
      AE := 196;
      UE := 220;
      OE := 244;
      lAnsiStr := '‰ˆ¸' + FORMAT(AE) + '÷' + FORMAT(UE) + 'ÈÍË‚‡Á' + FORMAT(OE);

      EXIT(CONVERTSTR(_Text,lAsciiStr,lAnsiStr));
    END;

    PROCEDURE EANGetControlKey@8016604(EANCode@8016600 : Code[13]) : Text[1];
    VAR
      locCalCle1@8016601 : Integer;
      locCalCle2@8016602 : Integer;
      locI@8016603 : Integer;
      locJ@8016607 : Integer;
      locCalSom@8016604 : Integer;
      locCalSup@8016605 : Integer;
    BEGIN
      locCalCle1 := 0;
      locCalCle2 := 0;

      locI := 1;
      WHILE locI < 13 DO BEGIN
        IF NOT EVALUATE(locJ,COPYSTR(EANCode,locI,1)) THEN
          EXIT('');
        locCalCle1 += locJ;
        locI += 2;
      END;

      locI := 2;
      WHILE locI < 13 DO BEGIN
        IF NOT EVALUATE(locJ,COPYSTR(EANCode,locI,1)) THEN
          EXIT(' ');
        locCalCle2 += locJ;
        locI += 2;
      END;

      locCalSom := (locCalCle2 * 3) + locCalCle1;
      FOR locI := 0 TO 9 DO BEGIN
        locCalSup := locCalSom + locI;
        locJ := locCalSup - (ROUND(locCalSup / 10,1) * 10);  // reste = 0 somme modulo 10
        IF locJ = 0 THEN
          EXIT(FORMAT(locI));
      END;

      EXIT(' ');
    END;

    PROCEDURE OptionToText@8016605(VarOption@8016600 : Option) : Text[250];
    BEGIN
      EXIT(FORMAT(VarOption,0,2));
    END;

    PROCEDURE IntegerToText@8016606(VarInteger@8016600 : Integer) : Text[250];
    BEGIN
      EXIT(FORMAT(VarInteger,0,2));
    END;

    PROCEDURE SQLDecimalToText@8016607(VarDecimal@8016600 : Decimal) ReturnValue@8016601 : Text[260];
    VAR
      DecimalSepSymbol@8016602 : Text[1];
    BEGIN
      DecimalSepSymbol := '.';

      ReturnValue :=
        FORMAT(VarDecimal,0,'<Sign><Integer><Decimals><Comma,' + DecimalSepSymbol + '>');
    END;

    PROCEDURE BooleanToText@8016608(VarBoolean@8016600 : Boolean) : Text[1];
    BEGIN
      EXIT(FORMAT(VarBoolean,1,2));
    END;

    PROCEDURE DateToText@8016609(VarDate@8016600 : Date) : Text[8];
    VAR
      VarText@8016601 : Text[8];
    BEGIN
      IF VarDate = 0D THEN
        VarText := '17530101'
      ELSE
        VarText := FORMAT(VarDate,0,'<Year4><Month,2><Day,2>');

      EXIT(VarText);
    END;

    PROCEDURE DateToText2@8016610(VarDate@8016600 : Date) : Text[8];
    VAR
      VarText@8016601 : Text[8];
    BEGIN
      IF VarDate = 0D THEN
        VarText := ''
      ELSE
        VarText := FORMAT(VarDate,0,'<Year4><Month,2><Day,2>');

      EXIT(VarText);
    END;

    PROCEDURE TimeToText@8016611(VarTime@8016600 : Time) ReturnTime@8016601 : Text[16];
    BEGIN
      ReturnTime := FORMAT(VarTime,0,'<Hours24,2>:<Minutes,2>:<Seconds,2>');

      IF ReturnTime = '' THEN
        ReturnTime := '00:00:00';
    END;

    PROCEDURE DateTimeToText@8016649(pDateTime@8016602 : DateTime) : Text[30];
    BEGIN
      //ISAT02.ST
      IF pDateTime = 0DT THEN
        EXIT('')
      ELSE
        EXIT(FORMAT(pDateTime, 0,'<Year4><Month,2><Day,2> <Hours24,2>:<Minutes,2>:<Seconds,2>'));
    END;

    PROCEDURE TextToInteger@8016612(VarText@8016600 : Text[250]) : Integer;
    VAR
      VarInteger@8016601 : Integer;
    BEGIN
      IF EVALUATE(VarInteger,VarText) THEN
        EXIT(VarInteger)
      ELSE
        EXIT(0);
    END;

    PROCEDURE TextToDecimal@8016613(VarText@8016600 : Text[250]) : Decimal;
    VAR
      VarDecimal@8016601 : Decimal;
      BaseVarDecimal@8016602 : Decimal;
      DecimalSymbol@8016603 : Text[1];
    BEGIN
      BaseVarDecimal := 1.2;
      DecimalSymbol := COPYSTR(FORMAT(BaseVarDecimal),2,1);
      EVALUATE(VarDecimal,CONVERTSTR(VarText,'.',DecimalSymbol));

      EXIT(VarDecimal);
    END;

    PROCEDURE TextToDecimal2@1100281002(VarText@8016600 : Text[250]) : Decimal;
    VAR
      VarDecimal@8016601 : Decimal;
      BaseVarDecimal@8016602 : Decimal;
      DecimalSymbol@8016603 : Text[1];
    BEGIN
      // = TextToDecimal + Gestion de la valeur nulle.
      IF VarText = '' THEN
        EXIT(0);

      EXIT(TextToDecimal(VarText));
    END;

    PROCEDURE TextToBoolean@8016614(VarText@8016600 : Text[1]) : Boolean;
    VAR
      VarBoolean@8016601 : Boolean;
    BEGIN
      IF NOT EVALUATE(VarBoolean,VarText) THEN
        VarBoolean := FALSE;

      EXIT(VarBoolean);
    END;

    PROCEDURE TextToBoolean2@1100281021(VarText@8016600 : Text[10]) : Boolean;
    BEGIN
      CASE VarText OF
        'true', '1' : EXIT(TRUE);
        'false', '0' : EXIT(FALSE);
      END;
      EXIT(FALSE);
    END;

    PROCEDURE TextToDate@8016615(pText@8016600 : Text[8]) rValue : Date;
    VAR
      lDay@8016601 : Integer;
      lMonth@8016602 : Integer;
      lYear@8016603 : Integer;
      lDate@8016604 : Date;
    BEGIN
      // IMH17.PC
      {
      IF VarText = '' THEN // isat02.st code dÇplacÇ
        EXIT(0D);

      IF NOT EVALUATE(VarDate,VarText) THEN
        EXIT(0D);
      // Format de date : aaaammdd
      Day := TextToInteger(COPYSTR(VarText,7,2));
      Month := TextToInteger(COPYSTR(VarText,5,2));
      Year := TextToInteger(COPYSTR(VarText,1,4));

      EXIT(DMY2DATE(Day,Month,Year));
      }

      rValue := 0D;

      IF pText = '' THEN BEGIN
        EXIT;
      END;

      // Format de date : aaaammdd
      lDay := TextToInteger(COPYSTR(pText,7,2));
      lMonth := TextToInteger(COPYSTR(pText,5,2));
      lYear := TextToInteger(COPYSTR(pText,1,4));

      rValue := DMY2DATE(lDay,lMonth,lYear);
    END;

    PROCEDURE TextToTime@8016616(VarText@8016600 : Text[8]) : Time;
    VAR
      VarTime@8016601 : Time;
      BaseVarTime@8016602 : Time;
      TimeSeparator@8016603 : Text[1];
    BEGIN
      BaseVarTime := 111111T;
      TimeSeparator := COPYSTR(FORMAT(BaseVarTime),3,1);
      //ISAT02.ST
      IF EVALUATE(VarTime,CONVERTSTR(VarText,':',TimeSeparator)) THEN
        EXIT(VarTime)
      ELSE
        EXIT(0T);
    END;

    PROCEDURE TextToDateTime@8016652(pText@8016602 : Text[250]) : DateTime;
    VAR
      lDate@8016603 : Date;
      lTime@8016604 : Time;
    BEGIN
      IF pText = '' THEN
        EXIT(0DT);
      // Format datetime : aaaammdd hh:mm:ss



      lDate := TextToDate(COPYSTR(pText, 1, 8));
      lTime := TextToTime(COPYSTR(pText, 10, 8));
      EXIT(CREATEDATETIME(lDate, lTime));
    END;

    PROCEDURE TextToDateTime2@1000000001(pText@8016602 : Text[250]) : DateTime;
    VAR
      lDate@8016603 : Date;
      lTime@8016604 : Time;
      lDay@1000000003 : Integer;
      lMonth@1000000002 : Integer;
      lYear@1000000001 : Integer;
    BEGIN
      // IMH18.PC

      IF pText = '' THEN BEGIN
        EXIT(0DT);
      END;

      // Format datetime : aaaa-mm-ddThh:mm:ss
      lDay := TextToInteger(COPYSTR(pText,9,2));
      lMonth := TextToInteger(COPYSTR(pText,6,2));
      lYear := TextToInteger(COPYSTR(pText,1,4));
      lDate := DMY2DATE(lDay,lMonth,lYear);
      lTime := TextToTime(COPYSTR(pText, 12, 8));
      EXIT(CREATEDATETIME(lDate, lTime));
    END;

    PROCEDURE SQLEncodeText@8016617(noEncodedText@8016600 : Text[250]) : Text[250];
    VAR
      EncodedText@8016601 : Text[250];
      i@8016602 : Integer;
    BEGIN
      EncodedText := '';
      FOR i := 1 TO STRLEN(noEncodedText) DO BEGIN
        EncodedText[STRLEN(EncodedText) + 1] := noEncodedText[i];
        IF noEncodedText[i] = '''' THEN
          EncodedText := EncodedText + '''';
      END;

      EXIT('''' + EncodedText + '''')
    END;

    PROCEDURE CSEncodeText@8016618(noEncodedText@8016600 : Text[250]) : Text[250];
    BEGIN
      EXIT(noEncodedText);
    END;

    PROCEDURE SQLEncodeCode@8016619(VarCode@8016600 : Code[250];Length@8016601 : Integer) : Text[250];
    BEGIN
      //EXIT(SQLEncodeText(CodeToText(VarCode,Length)));
    END;

    PROCEDURE CSEncodeCode@8016620(VarCode@8016600 : Code[250]) : Text[250];
    BEGIN
      EXIT(VarCode);
    END;

    PROCEDURE SQLEncodeOption@8016621(VarOption@8016600 : Option) : Text[250];
    BEGIN
      EXIT(SQLEncodeText(OptionToText(VarOption)));
    END;

    PROCEDURE CSEncodeOption@8016622(VarOption@8016600 : Option) : Text[250];
    BEGIN
      EXIT(CSEncodeText(OptionToText(VarOption)));
    END;

    PROCEDURE SQLEncodeInteger@8016623(VarInteger@8016600 : Integer) : Text[250];
    BEGIN
      EXIT(SQLEncodeText(IntegerToText(VarInteger)));
    END;

    PROCEDURE CSEncodeInteger@8016624(VarInteger@8016600 : Integer) : Text[250];
    BEGIN
      EXIT(CSEncodeText(IntegerToText(VarInteger)));
    END;

    PROCEDURE SQLEncodeDecimal@8016625(VarDecimal@8016600 : Decimal) : Text[250];
    BEGIN
      EXIT(SQLEncodeText(SQLDecimalToText(VarDecimal)));
    END;

    PROCEDURE CSEncodeDecimal@8016626(VarDecimal@8016600 : Decimal) : Text[250];
    BEGIN
      //EXIT(CSDecimalToText(VarDecimal));
    END;

    PROCEDURE SQLEncodeBoolean@8016627(VarBoolean@8016600 : Boolean) : Text[5];
    BEGIN
      EXIT(SQLEncodeText(BooleanToText(VarBoolean)));
    END;

    PROCEDURE CSEncodeBoolean@8016628(VarBoolean@8016600 : Boolean) : Text[5];
    BEGIN
      EXIT(CSEncodeText(BooleanToText(VarBoolean)));
    END;

    PROCEDURE SQLEncodeDate@8016629(VarDate@8016600 : Date) : Text[12];
    BEGIN
      EXIT(SQLEncodeText(DateToText(VarDate)));
    END;

    PROCEDURE CSEncodeDate@8016630(VarDate@8016600 : Date) : Text[12];
    BEGIN
      EXIT(CSEncodeText(DateToText(VarDate)));
    END;

    PROCEDURE SQLEncodeTime@8016631(VarTime@8016600 : Time) : Text[14];
    BEGIN
      EXIT(SQLEncodeText(TimeToText(VarTime)));
    END;

    PROCEDURE SQLEncodeDateTime@8016632(VarDate@8016601 : Date;VarTime@8016600 : Time) : Text[19];
    BEGIN
      EXIT(SQLEncodeText(DateToText(VarDate) + ' ' + TimeToText(VarTime)));
    END;

    PROCEDURE LeftPadCode@8016633(VarCode@8016600 : Code[250];MaxLength@8016601 : Integer;FillChar@8016602 : Text[1]) : Text[250];
    VAR
      Length@8016603 : Integer;
    BEGIN
      Length := MaxLength - STRLEN(VarCode);
      IF Length <= 0 THEN
        EXIT(VarCode);

      EXIT(PADSTR('',Length,FillChar) + VarCode);
    END;

    LOCAL PROCEDURE HEXEncode@8016634(Char@8016600 : Char) : Text[3];
    VAR
      AsciiValue@8016601 : Integer;
      a@8016602 : Integer;
      b@8016603 : Integer;
      HexValue@8016604 : Text[3];
    BEGIN
      AsciiValue := Char;

      IF AsciiValue > 255 THEN
        ERROR(Text000,Char);

      REPEAT
        a := AsciiValue DIV 16;
        b := AsciiValue - a * 16;
        AsciiValue := a;
        HexValue := COPYSTR('0123456789ABCDEF',b + 1,1) + HexValue;
      UNTIL AsciiValue = 0;

      IF STRLEN(HexValue) < 2 THEN
        HexValue := '0' + HexValue;

      EXIT('-' + HexValue);
    END;

    PROCEDURE RemoveBackslashIfThere@8016635(VAR Path@8016600 : Text[256]);
    BEGIN
      IF Path <> '' THEN BEGIN
        IF Path[STRLEN(Path)] = '\' THEN
          Path := COPYSTR(Path,1,STRLEN(Path) - 1);
      END;
    END;

    PROCEDURE MakeFilePath@8016636(FileFolder@8016600 : Text[256];FileName@8016601 : Text[256]) : Text[250];
    BEGIN
      IF FileName = '' THEN
        ERROR(Text001);
      IF FileFolder = '' THEN
        EXIT(FileName);

      EXIT(FileFolder + '\' + FileName);
    END;

    PROCEDURE ReportnoValidValue@8016637(Name@8016600 : Text[150];Value@8016601 : Text[256]);
    BEGIN
      IF Value = '' THEN
        ERROR(Text002,Name)
      ELSE
        ERROR(Text003,Value,Name);
    END;

    PROCEDURE CheckForInvCharAndMakeDescript@8016638(FieldName@8016600 : Text[250];FieldValue@8016601 : Text[250];VAR Description@8016602 : Text[250]);
    VAR
      i@8016603 : Integer;
    BEGIN
      FOR i := 1 TO STRLEN(FieldValue) DO
        IF FieldValue[i] IN ['.',',',' '] THEN
          ERROR(Text004,FieldName);

      IF FieldValue = '' THEN
        Description := ''
      ELSE
        Description := UPPERCASE(COPYSTR(FieldValue,1,1)) + LOWERCASE(COPYSTR(FieldValue,2));
    END;

    PROCEDURE AdjustNeNo@8016639(VAR PrinterSelection@8016600 : Record 78);
    VAR
      printer@8016601 : Record 2000000039;
    BEGIN
      IF printer.GET(PrinterSelection."Printer Name") THEN
         EXIT;

      IF PrinterSelection."Printer Name"<>'' THEN BEGIN
        printer.SETRANGE(Name,SELECTSTR(1,PrinterSelection."Printer Name"));
        IF printer.FIND('-') THEN
          PrinterSelection."Printer Name":=printer.ID
        ELSE
          ERROR('Printer queue %1 does no exist.',PrinterSelection."Printer Name");
      END;
    END;

    PROCEDURE CalcDateDecade@8016640(PaymentTermsRec@8016600 : Record 3;RefDate@8016601 : Date) : Date;
    BEGIN
      { EC 18/05/05
      RefDate := CALCDATE(PaymentTermsRec."Due Date Calculation",RefDate);
      IF PaymentTermsRec.DÇcade THEN
        IF DATE2DMY(RefDate,1) <= 10 THEN
          RefDate := DMY2DATE(10,DATE2DMY(RefDate,2),DATE2DMY(RefDate,3))
        ELSE
          IF DATE2DMY(RefDate,1) <= 20 THEN
            RefDate := DMY2DATE(20,DATE2DMY(RefDate,2),DATE2DMY(RefDate,3))
          ELSE
            RefDate := CALCDATE('FM',RefDate);
      EXIT(RefDate);
      }
    END;

    PROCEDURE UnLockOT@8016641();
    VAR
      locReservationEntry@8016600 : Record 337;
      locText001@8016601 : TextConst 'FRA=Souhaitez-vous dÇvÇryesller l''ordre de transfert ?';
      locText002@8016602 : TextConst 'ENU=Processing finished.;FRA=Traitement terminÇ.';
    BEGIN
      IF NOT CONFIRM(locText001) THEN BEGIN
        ERROR('');
      END;

      WITH locReservationEntry DO BEGIN
        SETRANGE("Source Type",83);
        SETRANGE("Source Subtype",4);
        SETRANGE("Source ID",'');
        SETRANGE("Source Batch Name",'');
        SETRANGE("Source Prod. Order Line",0);
        SETRANGE("Source Ref. No.",0);

        IF FIND('-') THEN BEGIN
          REPEAT
            DELETE(TRUE);
          UNTIL NEXT = 0;
        END;
      END;

      MESSAGE(locText002);
    END;

    PROCEDURE InitFooterComment@8016642(parTextCode@8016600 : Code[20];parLanguageCode@8016601 : Code[10];VAR parFooterDocument@8016602 : ARRAY [10] OF Text[50]);
    VAR
      locExtendedTextHeader@8016605 : Record 279;
      locExtendedTextLine@8016604 : Record 280;
      locI@8016603 : Integer;
    BEGIN

      FOR locI := 1 TO 10 DO BEGIN
        parFooterDocument[locI] := '';
      END;

      locI := 1;

      IF parTextCode <> '' THEN BEGIN
        locExtendedTextHeader.RESET;
        locExtendedTextHeader.SETRANGE("Table Name",locExtendedTextHeader."Table Name"::"Standard Text");
        locExtendedTextHeader.SETRANGE("No.",parTextCode);
        locExtendedTextHeader.SETRANGE("All Language Codes",TRUE);
        IF locExtendedTextHeader.FIND('-') THEN BEGIN
          REPEAT
            locExtendedTextLine.RESET;
            locExtendedTextLine.SETRANGE("Table Name",locExtendedTextHeader."Table Name"::"Standard Text");
            locExtendedTextLine.SETRANGE("No.",locExtendedTextHeader."No.");
            locExtendedTextLine.SETRANGE("Language Code",locExtendedTextHeader."Language Code");
            locExtendedTextLine.SETRANGE("Text No.",locExtendedTextHeader."Text No.");
            IF locExtendedTextLine.FIND('-') THEN BEGIN
              REPEAT
                IF locI <= 10 THEN BEGIN
                  parFooterDocument[locI] := locExtendedTextLine.Text;
                  locI += 1;
                END;
              UNTIL locExtendedTextLine.NEXT = 0;
            END;
          UNTIL locExtendedTextHeader.NEXT = 0;
        END;

        locExtendedTextHeader.RESET;
        locExtendedTextHeader.SETRANGE("Table Name",locExtendedTextHeader."Table Name"::"Standard Text");
        locExtendedTextHeader.SETRANGE("No.",parTextCode);
        locExtendedTextHeader.SETRANGE("Language Code",parLanguageCode);
        locExtendedTextHeader.SETRANGE("All Language Codes",FALSE);
        IF locExtendedTextHeader.FIND('-') THEN BEGIN
          REPEAT
            locExtendedTextLine.RESET;
            locExtendedTextLine.SETRANGE("Table Name",locExtendedTextHeader."Table Name"::"Standard Text");
            locExtendedTextLine.SETRANGE("No.",locExtendedTextHeader."No.");
            locExtendedTextLine.SETRANGE("Language Code",locExtendedTextHeader."Language Code");
            locExtendedTextLine.SETRANGE("Text No.",locExtendedTextHeader."Text No.");
            IF locExtendedTextLine.FIND('-') THEN BEGIN
              REPEAT
                IF locI <= 10 THEN BEGIN
                  parFooterDocument[locI] := locExtendedTextLine.Text;
                  locI += 1;
                END;
              UNTIL locExtendedTextLine.NEXT = 0;
            END;
          UNTIL locExtendedTextHeader.NEXT = 0;
        END ELSE BEGIN
          locExtendedTextHeader.RESET;
          locExtendedTextHeader.SETRANGE("Table Name",locExtendedTextHeader."Table Name"::"Standard Text");
          locExtendedTextHeader.SETRANGE("No.",parTextCode);
          locExtendedTextHeader.SETRANGE("Language Code",'');
          locExtendedTextHeader.SETRANGE("All Language Codes",FALSE);
          IF locExtendedTextHeader.FIND('-') THEN BEGIN
            REPEAT
              locExtendedTextLine.RESET;
              locExtendedTextLine.SETRANGE("Table Name",locExtendedTextHeader."Table Name"::"Standard Text");
              locExtendedTextLine.SETRANGE("No.",locExtendedTextHeader."No.");
              locExtendedTextLine.SETRANGE("Language Code",'');
              locExtendedTextLine.SETRANGE("Text No.",locExtendedTextHeader."Text No.");
              IF locExtendedTextLine.FIND('-') THEN BEGIN
                REPEAT
                  IF locI <= 10 THEN BEGIN
                    parFooterDocument[locI] := locExtendedTextLine.Text;
                    locI += 1;
                  END;
                UNTIL locExtendedTextLine.NEXT = 0;
              END;
            UNTIL locExtendedTextHeader.NEXT = 0;
          END;
        END;
      END;
    END;

    LOCAL PROCEDURE GetAnsiStr@1000000009() @1000000001 : Text[100];
    VAR
      i@1000000000 : Integer;
    BEGIN
      IF ANSIText = '' THEN BEGIN
        // Lettres accentuÇes
        FOR i := 1 TO 64 DO BEGIN
          ANSIText[i] := 191 + i;
        END;
        // Ajout d'autres caractäres spÇciaux
        ANSIText[65] := 176;
        ANSIText[66] := 177;
        ANSIText[67] := 178;
      END;
      EXIT(ANSIText);
    END;

    LOCAL PROCEDURE GetAsciiStr@1000000011() @1000000000 : Text[100];
    BEGIN
      ///////////////192     200       210       220       230       240       250
      ////////////////2345678901234567890123456789012345678901234567890123456789012345
      EXIT('∑µ∂«éèíÄ‘ê“”ﬁ÷◊ÿ—•„‡‚ÂôûùÎÈÍöÌË·Ö†É∆ÑÜëáäÇàâç°åã–§ï¢ì‰îˆõó£ñÅÏÁò' +
           '¯Ò˝');
    END;

    PROCEDURE FormatExport@1000000013(_Text@1000000000 : Text[1024]) : Text[1024];
    BEGIN
      EXIT(CONVERTSTR(_Text,GetAsciiStr,GetAnsiStr));
    END;

    PROCEDURE FormatImport@1000000014(_Text@1000000000 : Text[1024]) : Text[1024];
    BEGIN
      EXIT(CONVERTSTR(_Text,GetAnsiStr,GetAsciiStr));
    END;

    PROCEDURE GetCharNo@1100281000(pText@1100281000 : Text[1024];pChar@1100281001 : Text[1]) : Integer;
    VAR
      lText@1100281002 : Text[1024];
      lCount@1100281003 : Integer;
      lPos@1100281004 : Integer;
      lEnd@1100281005 : Boolean;
    BEGIN
      // IMH02
      // Compte le nombre de caractäres dans une chaåne
      lText := pText;
      REPEAT
        lPos := STRPOS(lText,pChar);
        IF lPos <> 0 THEN
          lCount += 1
        ELSE
          lEnd := TRUE;
        lText := COPYSTR(lText,lPos +1,STRLEN(lText)-lPos);
      UNTIL lEnd = TRUE;
      EXIT(lCount);
    END;

    PROCEDURE GetDayDuration@1100281001(pStartDateTime@1100281000 : DateTime;pEndDateTime@1100281001 : DateTime) : Decimal;
    VAR
      lDayMs@1100281002 : Decimal;
    BEGIN
      //IMH03
      IF (pStartDateTime = 0DT) OR (pEndDateTime = 0DT) THEN
        EXIT;
      lDayMs := (1000*60*60*24);
      EXIT((pEndDateTime - pStartDateTime)/lDayMs);
    END;

    PROCEDURE CalcDateTmeByFormula@1100281004(pDateTime@1100281000 : DateTime;pDateFormula@1100281001 : DateFormula;pTimeFormula@1100281002 : Integer) : DateTime;
    VAR
      lDateInt@1100281007 : Integer;
      lDate@1100281008 : Date;
      lTime@1100281003 : Time;
      lDateTime@1100281004 : DateTime;
      lDateTime2@1100281005 : DateTime;
      lDuration@1100281006 : Duration;
    BEGIN
      //IMH04 isat.zw
      IF pTimeFormula < 0 THEN
        EXIT;

      IF pTimeFormula > 24 THEN BEGIN
        lDateInt := ROUND(pTimeFormula DIV 24, 1, '<');
        EVALUATE(lTime, FORMAT(pTimeFormula MOD 24));
      END ELSE
        EVALUATE(lTime, FORMAT(pTimeFormula));

      IF FORMAT(pDateFormula) <> '' THEN
        lDate := CALCDATE(pDateFormula, TODAY)
      ELSE
        lDate := TODAY;
      lDateTime := CREATEDATETIME(TODAY, 0T);
      lDateTime2 := CREATEDATETIME(lDate + lDateInt, lTime);
      lDuration := lDateTime2 - lDateTime;

      EXIT(pDateTime + lDuration);
    END;

    PROCEDURE ChangeSpecChar@1100281013(pString@1100281000 : Text[250];pExtension@1100281005 : Text[250]) : Text[250];
    VAR
      lFromChar@1100281001 : Text[100];
      lToChar@1100281004 : Text[100];
      i@1100281002 : Integer;
      lText001@1100281003 : TextConst 'ENU='';FRA=''';
    BEGIN
      {
      lFromChar := '1234567890AEIOUYC∑µ∂«éèíÄ‘ê“”ﬁ÷◊ÿ—•„‡‚ÂôûùÎÈÍöÌË·Ö†É∆ÑÜëáäÇàâç°åã–§ï¢ì‰îˆõó£ñÅÏÁò()-';
      FOR i := 1 TO STRLEN(pString) DO BEGIN
        IF STRPOS(lSpecChar, FORMAT(pString[i])) <> 0 THEN
          pString[i] := '?';
      END;
      EXIT(pString);
      }
      lFromChar := '∑µ∂«éèíÄ‘ê“”ﬁ÷◊ÿ—•„‡‚ÂôûùÎÈÍöÌË·Ö†É∆ÑÜëáäÇàâç°åã–§ï¢ì‰îˆõó£ñÅÏÁò()-';
      lToChar   := '???????????????????????????????????????????????????????????????????';

      pString := CONVERTSTR(pString,lFromChar,lToChar);
      IF STRLEN(pExtension) <> 0 THEN BEGIN
        pString := CONVERTSTR(pString,pExtension,PADSTR('?',STRLEN(pExtension)));
      END;

      EXIT(pString);
    END;

    PROCEDURE CheckCity@1100281006(VAR pPostCode@1100281008 : Code[20];VAR pCity@1100281002 : Text[30]) : Boolean;
    VAR
      lPostCode@1100281000 : Record 225;
      Text000@1100281004 : TextConst 'FRA=''';
      lCity@1100281005 : Text[50];
      lPos@1100281006 : Integer;
      lTempCity@1100281009 : Text[50];
    BEGIN
      // IMH06.ISAT.MA Normalisation de la ville

      IF STRLEN(pPostCode) < 5 THEN
        pPostCode := '0' + pPostCode;

      // Correspondance directe
      lPostCode.RESET;
      //<<IMH09.isat.PC
      //lPostCode.SETCURRENTKEY("City (Without Accent)");
      //lPostCode.SETRANGE("City (Without Accent)",pCity);
      lPostCode.SETCURRENTKEY("Large Des. (Without Accent)");
      lPostCode.SETRANGE("Large Des. (Without Accent)",pCity);
      //>>IMH09.isat.PC
      lPostCode.SETRANGE(Code,pPostCode);
      IF lPostCode.FINDFIRST THEN BEGIN
        pCity := lPostCode.City;
        pPostCode := lPostCode.Code;
        EXIT(TRUE);
      END;

      // Correspondance nom ville et dÇpartement
      lPostCode.RESET;
      //<<IMH09.isat.PC
      //lPostCode.SETCURRENTKEY("City (Without Accent)");
      //lPostCode.SETRANGE("City (Without Accent)",pCity);
      lPostCode.SETCURRENTKEY("Large Des. (Without Accent)");
      lPostCode.SETRANGE("Large Des. (Without Accent)",pCity);
      //>>IMH09.isat.PC
      lPostCode.SETRANGE("Area Code",COPYSTR(pPostCode,1,2));
      IF lPostCode.FINDFIRST THEN BEGIN
        pCity := lPostCode.City;
        pPostCode := lPostCode.Code;
        EXIT(TRUE);
      END;

      pCity := CheckArrond(pCity);

      // Transformation des Çventuels saint, sainte, etc...
      lCity := CONVERTSTR(pCity, ' ','-');
      lPos := STRPOS(lCity,'-CEDEX');
      IF lPos > 0 THEN
        lCity := COPYSTR(lCity,1,lPos - 1);
      lPos := STRPOS(lCity,'-S-');
      IF lPos > 0 THEN BEGIN
        lCity := DELSTR(lCity, lPos,3);
        lCity := INSSTR(lCity, '-SUR-',lPos);
      END;
      lPos := STRPOS(lCity,'-SS-');
      IF lPos > 0 THEN BEGIN
        lCity := DELSTR(lCity, lPos,4);
        lCity := INSSTR(lCity, '-SOUS-',lPos);
      END;
      lPos := STRPOS(lCity,'-ST-');
      IF lPos > 0 THEN BEGIN
        lCity := DELSTR(lCity, lPos,4);
        lCity := INSSTR(lCity, '-SAINT-',lPos);
      END;
      IF COPYSTR(lCity,1,3) = 'ST-' THEN BEGIN;
        lPos := STRPOS(lCity,'ST-');
        IF lPos > 0 THEN BEGIN
          lCity := DELSTR(lCity, lPos,3);
          lCity := INSSTR(lCity, 'SAINT-',lPos);
        END;
      END;
      lPos := STRPOS(lCity,'-STE-');
      IF lPos > 0 THEN BEGIN
        lCity := DELSTR(lCity, lPos,5);
        lCity := INSSTR(lCity, '-SAINTE-',lPos);
      END;
      lPos := STRPOS(lCity,'STE-');
      IF lPos > 0 THEN BEGIN
        lCity := DELSTR(lCity, lPos,4);
        lCity := INSSTR(lCity, 'SAINTE-',lPos);
      END;

      // Correspondance directe
      lPostCode.RESET;
      //<<IMH09.isat.PC
      //lPostCode.SETCURRENTKEY("City (Without Accent)");
      //lPostCode.SETRANGE("City (Without Accent)",pCity);
      lPostCode.SETCURRENTKEY("Large Des. (Without Accent)");
      // <<IMH10.ISAT.MA
      //lPostCode.SETRANGE("Large Des. (Without Accent)",pCity);
      lPostCode.SETRANGE("Large Des. (Without Accent)",lCity);
      // >>IMH10.ISAT.MA
      //>>IMH09.isat.PC
      lPostCode.SETRANGE(Code,pPostCode);
      IF lPostCode.FINDFIRST THEN BEGIN
        pCity := lPostCode.City;
        pPostCode := lPostCode.Code;
        EXIT(TRUE);
      END;

      // Correspondance nom ville et dÇpartement
      lPostCode.RESET;
      //<<IMH09.isat.PC
      //lPostCode.SETCURRENTKEY("City (Without Accent)");
      //lPostCode.SETRANGE("City (Without Accent)",pCity);
      lPostCode.SETCURRENTKEY("Large Des. (Without Accent)");
      // <<IMH10.ISAT.MA
      //lPostCode.SETRANGE("Large Des. (Without Accent)",pCity);
      lPostCode.SETRANGE("Large Des. (Without Accent)",lCity);
      // >>IMH10.ISAT.MA
      //>>IMH09.isat.PC
      lPostCode.SETRANGE("Area Code",COPYSTR(pPostCode,1,2));
      IF lPostCode.FINDFIRST THEN BEGIN
        pCity := lPostCode.City;
        pPostCode := lPostCode.Code;
        EXIT(TRUE);
      END;

      lCity := ChangeSpecChar(lCity,'');

      // Correspondance directe
      lPostCode.RESET;
      //<<IMH09.isat.PC
      //lPostCode.SETCURRENTKEY("City (Without Accent)");
      //lPostCode.SETRANGE("City (Without Accent)",pCity);
      lPostCode.SETCURRENTKEY("Large Des. (Without Accent)");
      // <<IMH10.ISAT.MA
      //lPostCode.SETRANGE("Large Des. (Without Accent)",pCity);
      lPostCode.SETFILTER("Large Des. (Without Accent)",lCity);
      // >>IMH10.ISAT.MA
      //>>IMH09.isat.PC
      lPostCode.SETRANGE(Code,pPostCode);
      IF lPostCode.FINDFIRST THEN
      BEGIN
        pCity := lPostCode.City;
        pPostCode := lPostCode.Code;
        EXIT(TRUE);
      END;

      // Correspondance nom ville et dÇpartement
      lPostCode.RESET;
      //<<IMH09.isat.PC
      //lPostCode.SETCURRENTKEY("City (Without Accent)");
      //lPostCode.SETRANGE("City (Without Accent)",pCity);
      lPostCode.SETCURRENTKEY("Large Des. (Without Accent)");
      // <<IMH10.ISAT.MA
      //lPostCode.SETRANGE("Large Des. (Without Accent)",pCity);
      lPostCode.SETFILTER("Large Des. (Without Accent)",lCity);
      // >>IMH10.ISAT.MA
      //>>IMH09.isat.PC
      lPostCode.SETRANGE("Area Code",COPYSTR(pPostCode,1,2));
      IF lPostCode.FINDFIRST THEN
      BEGIN
        pCity := lPostCode.City;
        pPostCode := lPostCode.Code;
        EXIT(TRUE);
      END;

      //<<IMH09.isat.PC
      {
      IF lRDDCity.GET('',pPostCode,pCity) THEN
      BEGIN
        pPostCode := lRDDCity."Post Code";
        pCity := lRDDCity."New City";
        EXIT(TRUE);
      END;

      lRDDCity."Provider No." := '';
      lRDDCity."Old Post Code" := pPostCode;
      lRDDCity."Old City" := pCity;
      IF NOT lRDDCity.INSERT(TRUE) THEN;
      EXIT(FALSE);
      }
      //>>IMH09.isat.PC
    END;

    PROCEDURE CheckCity2@1100281007(VAR pPostCode@1100281000 : Code[30];VAR pCity@1100281001 : Text[30]) : Boolean;
    VAR
      lPostCode@1100281002 : Record 225;
      lCity@1100281003 : Text[50];
      lPos@1100281005 : Integer;
    BEGIN
      //IMH07 ZW  Normalisation de la ville + gestion arrondissement
      IF (pPostCode = '') OR (pCity = '') THEN BEGIN
        EXIT;
      END;
      // Correspondance directe
      lPostCode.RESET;
      lPostCode.SETCURRENTKEY("City (Without Accent)");
      lPostCode.SETRANGE("City (Without Accent)",pCity);
      lPostCode.SETRANGE(Code,pPostCode);
      IF lPostCode.FINDFIRST THEN BEGIN
        pCity := lPostCode.City;
        pPostCode := lPostCode.Code;
        EXIT(TRUE);
      END;

      // Correspondance nom ville et dÇpartement
      lPostCode.RESET;
      lPostCode.SETCURRENTKEY("City (Without Accent)");
      lPostCode.SETRANGE("City (Without Accent)",pCity);
      lPostCode.SETRANGE("Area Code",COPYSTR(pPostCode,1,2));
      IF lPostCode.FINDFIRST THEN BEGIN
        pCity := lPostCode.City;
        pPostCode := lPostCode.Code;
        EXIT(TRUE);
      END;

      pCity := CheckArrond(pCity);

      // Trasnformation des Çventuels saint, sainte, etc...
      lCity := CONVERTSTR(pCity, ' ','-');
      lPos := STRPOS(lCity,'-CEDEX');
      IF lPos > 0 THEN
        lCity := COPYSTR(lCity,1,lPos - 1);
      lPos := STRPOS(lCity,'-S-');
      IF lPos > 0 THEN BEGIN
        lCity := DELSTR(lCity, lPos,3);
        lCity := INSSTR(lCity, '-SUR-',lPos);
      END;
      lPos := STRPOS(lCity,'-SS-');
      IF lPos > 0 THEN BEGIN
        lCity := DELSTR(lCity, lPos,4);
        lCity := INSSTR(lCity, '-SOUS-',lPos);
      END;
      lPos := STRPOS(lCity,'-ST-');
      IF lPos > 0 THEN BEGIN
        lCity := DELSTR(lCity, lPos,4);
        lCity := INSSTR(lCity, '-SAINT-',lPos);
      END;
      IF COPYSTR(lCity,1,3) = 'ST-' THEN BEGIN;
        lPos := STRPOS(lCity,'ST-');
        IF lPos > 0 THEN BEGIN
          lCity := DELSTR(lCity, lPos,3);
          lCity := INSSTR(lCity, 'SAINT-',lPos);
        END;
      END;
      lPos := STRPOS(lCity,'-STE-');
      IF lPos > 0 THEN BEGIN
        lCity := DELSTR(lCity, lPos,5);
        lCity := INSSTR(lCity, '-SAINTE-',lPos);
      END;
      lPos := STRPOS(lCity,'STE-');
      IF lPos > 0 THEN BEGIN
        lCity := DELSTR(lCity, lPos,4);
        lCity := INSSTR(lCity, 'SAINTE-',lPos);
      END;

      // Correspondance directe
      lPostCode.RESET;
      lPostCode.SETCURRENTKEY("City (Without Accent)");
      lPostCode.SETRANGE("City (Without Accent)",lCity);
      lPostCode.SETRANGE(Code,pPostCode);
      IF lPostCode.FINDFIRST THEN BEGIN
        pCity := lPostCode.City;
        pPostCode := lPostCode.Code;
        EXIT(TRUE);
      END;

      // Correspondance nom ville et dÇpartement
      lPostCode.RESET;
      lPostCode.SETCURRENTKEY("City (Without Accent)");
      lPostCode.SETRANGE("City (Without Accent)",lCity);
      lPostCode.SETRANGE("Area Code",COPYSTR(pPostCode,1,2));
      IF lPostCode.FINDFIRST THEN BEGIN
        pCity := lPostCode.City;
        pPostCode := lPostCode.Code;
        EXIT(TRUE);
      END;

      lCity := ChangeSpecChar2(lCity);

      // Correspondance directe
      lPostCode.RESET;
      lPostCode.SETCURRENTKEY("City (Without Accent)");
      lPostCode.SETFILTER("City (Without Accent)",lCity);
      lPostCode.SETRANGE(Code,pPostCode);
      IF lPostCode.FINDFIRST THEN BEGIN
        pCity := lPostCode.City;
        pPostCode := lPostCode.Code;
        EXIT(TRUE);
      END;

      // Correspondance nom ville et dÇpartement
      lPostCode.RESET;
      lPostCode.SETCURRENTKEY("City (Without Accent)");
      lPostCode.SETFILTER("City (Without Accent)",lCity);
      lPostCode.SETRANGE("Area Code",COPYSTR(pPostCode,1,2));
      IF lPostCode.FINDFIRST THEN BEGIN
        pCity := lPostCode.City;
        pPostCode := lPostCode.Code;
        EXIT(TRUE);
      END;

      lCity := CONVERTSTR(pCity,'-',' ');
      lCity := ChangeSpecChar2(lCity);

      // Correspondance directe
      lPostCode.RESET;
      lPostCode.SETCURRENTKEY("City (Without Accent)");
      lPostCode.SETRANGE("City (Without Accent)",lCity);
      lPostCode.SETRANGE(Code,pPostCode);
      IF lPostCode.FINDFIRST THEN BEGIN
        pCity := lPostCode.City;
        pPostCode := lPostCode.Code;
        EXIT(TRUE);
      END;

      // Correspondance nom ville et dÇpartement
      lPostCode.RESET;
      lPostCode.SETCURRENTKEY("City (Without Accent)");
      lPostCode.SETRANGE("City (Without Accent)",lCity);
      lPostCode.SETRANGE("Area Code",COPYSTR(pPostCode,1,2));
      IF lPostCode.FINDFIRST THEN BEGIN
        pCity := lPostCode.City;
        pPostCode := lPostCode.Code;
        EXIT(TRUE);
      END;

      lCity := ChangeSpecChar2(lCity);

      // Correspondance directe
      lPostCode.RESET;
      lPostCode.SETCURRENTKEY("City (Without Accent)");
      lPostCode.SETFILTER("City (Without Accent)",lCity);
      lPostCode.SETRANGE(Code,pPostCode);
      IF lPostCode.FINDFIRST THEN BEGIN
        pCity := lPostCode.City;
        pPostCode := lPostCode.Code;
        EXIT(TRUE);
      END;

      // Correspondance nom ville et dÇpartement
      lPostCode.RESET;
      lPostCode.SETCURRENTKEY("City (Without Accent)");
      lPostCode.SETFILTER("City (Without Accent)",lCity);
      lPostCode.SETRANGE("Area Code",COPYSTR(pPostCode,1,2));
      IF lPostCode.FINDFIRST THEN BEGIN
        pCity := lPostCode.City;
        pPostCode := lPostCode.Code;
        EXIT(TRUE);
      END;
    END;

    PROCEDURE CheckArrond@1100281008(pCity@1100281000 : Text[30]) rValue : Text[30];
    VAR
      lFirstTime@1100281001 : Boolean;
      i@1100281002 : Integer;
      lTempCity@1100281003 : Text[30];
      lArronFound@1100281004 : Boolean;
    BEGIN
      //IMH07 ZW  Normalisation de la ville + gestion arrondissement
      // gestion des arrondissements

      rValue := pCity;

      lFirstTime := TRUE;
      lArronFound := FALSE;
      i := 0;
      REPEAT
        i += 1;
        IF (pCity[i] IN ['1','2','3','4','5','6','7','8','9','0']) THEN BEGIN
          IF lFirstTime THEN BEGIN
            lTempCity += ' ';
            lFirstTime := FALSE;
            lArronFound := TRUE;
          END;
        END;
        lTempCity += FORMAT(pCity[i]);
        IF (i = STRLEN(pCity)) AND lArronFound THEN BEGIN
          lTempCity += 'E';
        END;
      //UNTIL i = STRLEN(pCity);
      UNTIL (i = STRLEN(pCity)) OR (i >= MAXSTRLEN(pCity));

      rValue := lTempCity;
    END;

    PROCEDURE TestPhoneNo@1100281012(pCountryCode@1100281002 : Code[20];VAR pTextValue@1100281000 : Text[30]) : Boolean;
    VAR
      lPhoneStandardization@1100281007 : Codeunit 50099;
      lCountry@1100281006 : Record 9;
      lInternPrefix@1100281001 : Text[30];
      lValue@1100281008 : Text[30];
      lValue2@1100281009 : Text[30];
      lPos@1100281003 : Integer;
      lReplaceChar@1100281004 : Char;
      lExitLoop@1100281005 : Boolean;
      lCompanyInformation@1100281010 : Record 79;
    BEGIN
      //IMH07 ZW
      // test avant intÇgration

      lValue := pTextValue;
      IF NOT lCountry.GET(pCountryCode) THEN BEGIN
        lCompanyInformation.GET;
        IF NOT lCountry.GET(lCompanyInformation."Country/Region Code") THEN
          EXIT(FALSE);
        pCountryCode := lCompanyInformation."Country/Region Code";
      END;
      IF (lCountry."Phone No. Format" = '') OR (lValue = '') THEN
        EXIT(TRUE);

      // Suppression des blancs
      lValue := DELCHR(lValue, '=', ' ');
      lPos := STRLEN(lValue);
      IF lPos = 0 THEN BEGIN
        pTextValue := lValue;
        EXIT(TRUE);
      END;

      // VÇrifie la longueur du numÇro
      IF STRLEN(lValue) <> lCountry."Phone Local Nos" THEN
        EXIT(FALSE);

      lReplaceChar := 'X';
      lValue2 := lCountry."Phone No. Format";
      REPEAT
        //<<IMH08.isat.PC
        lPhoneStandardization.SetHideMessage(TRUE);
        //>>IMH08.isat.PC
        IF lPhoneStandardization.ReplaceLastChar(lValue2, lReplaceChar, lValue[lPos]) THEN
          lPos := lPos - 1
        ELSE
          lExitLoop := TRUE;
      UNTIL lExitLoop OR (lPos=0);

      pTextValue := lValue2;

      IF lPos = 0 THEN
        EXIT(TRUE);
      // Contrìle du reste de pTextValue
      IF lPos > 0 THEN BEGIN
        IF lCountry."Phone International Prefix No." <> '' THEN BEGIN
          IF COPYSTR(lValue, 1, lPos) = STRSUBSTNO('+%1', lCountry."Phone International Prefix No.") THEN BEGIN
            EXIT(TRUE);
          END;
        END;

        // Identique Ö l'indicatif ou Çgal Ö 0 (pour la france)
        IF (COPYSTR(lValue,1, lPos) = STRSUBSTNO('+%1',lCountry."Phone International Prefix No.")) OR
           (COPYSTR(lValue,1, lPos) = '0') THEN
          EXIT(TRUE)
        ELSE
          EXIT(FALSE);
      END;

      EXIT(TRUE);
    END;

    PROCEDURE Ansi2utf8@1100281005(pText@1100281000 : Text[1024]) : Text[1024];
    VAR
      lPos@1100281001 : Integer;
      lText@1100281002 : Text[1024];
      lChar1@1100281003 : Char;
      lChar2@1100281004 : Char;
    BEGIN
      //utf8Str := 'ÑîÅéôöÇàäÉÖáì';

      AE := 196;
      UE := 220;
      OE := 244;

      lChar1 := 195;
      lChar2 := 169;

      lText := pText;
      lPos := STRPOS(pText,'Ç');
      IF lPos <> 0 THEN
      BEGIN
        lText := DELSTR(lText, lPos,1);
        lText := INSSTR(lText,FORMAT(lChar1) + FORMAT('%02X'),lPos);
      END;

      EXIT(lText);
    END;

    PROCEDURE BigTextAnsi2Ascii@1100281003(VAR pBigText@1100281000 : BigText);
    VAR
      lFromBigtext@1100281002 : BigText;
      lToBigText@1100281001 : BigText;
      lText@1100281004 : Text[1024];
      i@1100281003 : Integer;
      lFile@1100281005 : File;
      lOutStream@1100281007 : OutStream;
      lFileName@1100281008 : Text[250];
    BEGIN
      // IMH07.ISAT.MA

      lFromBigtext := pBigText;
      FOR i := 0 TO ROUND(pBigText.LENGTH / 1024,1,'<') DO
      BEGIN
        IF i = 0 THEN
          pBigText.GETSUBTEXT(lText,1,1024)
        ELSE
          pBigText.GETSUBTEXT(lText, (i * 1024),1024);
        lToBigText.ADDTEXT(Ansi2utf8(lText));
      END;
      pBigText := lToBigText;

      // Pour test
      lFileName := TEMPORARYPATH + 'ToBigText\ToBigText_' + FORMAT(TIME,0,'<Hours,2><Minutes,2><Seconds,2>') + '.txt';
      lFile.CREATE(lFileName);
      lFile.TEXTMODE(TRUE);
      lFile.WRITEMODE(TRUE);
      lFile.OPEN(lFileName);
      lFile.CREATEOUTSTREAM(lOutStream);
      lToBigText.WRITE(lOutStream);
      lFile.CLOSE;
    END;

    PROCEDURE HasValue@1100281010(FldRef@1100281000 : FieldRef) : Boolean;
    VAR
      Field@1100281001 : Record 2000000041;
      HasValue@1100281002 : Boolean;
      Int@1100281003 : Integer;
      Dec@1100281004 : Decimal;
      D@1100281005 : Date;
      T@1100281006 : Time;
    BEGIN
      //<<IMH08.ISAT.EBA
      EVALUATE(Field.Type,FORMAT(FldRef.TYPE));
      CASE Field.Type OF
        Field.Type::Boolean:
          HasValue := FldRef.VALUE;
        Field.Type::Option:
          HasValue := FALSE;
        Field.Type::Integer:
          BEGIN
            Int := FldRef.VALUE;
            HasValue := Int <> 0;
          END;
        Field.Type::Decimal:
          BEGIN
            Dec := FldRef.VALUE;
            HasValue := Dec <> 0;
          END;
        Field.Type::Date:
          BEGIN
            D := FldRef.VALUE;
            HasValue := D <> 0D;
          END;
        Field.Type::Time:
          BEGIN
            T := FldRef.VALUE;
            HasValue := T <> 0T;
          END;
        Field.Type::BLOB:
          HasValue := FALSE;
        ELSE
          HasValue := FORMAT(FldRef.VALUE) <> '';
      END;

      EXIT(HasValue);
      //>>IMH08.ISAT.EBA
    END;

    PROCEDURE TextToDate2@1100281011(pText@1100281000 : Text[8]) rValue : Date;
    VAR
      lDay@1100281001 : Integer;
      lMonth@1100281002 : Integer;
      lYear@1100281003 : Integer;
    BEGIN
      //<<IMH08.ISAT.EBA
      rValue := 0D;

      IF (pText = '') OR (pText='99999999') THEN BEGIN
        EXIT;
      END;

      IF STRLEN(pText) <> 8 THEN BEGIN
        EXIT;
      END;

      // Format de date : aaaammdd
      lDay := TextToInteger(COPYSTR(pText,7,2));
      lMonth := TextToInteger(COPYSTR(pText,5,2));
      lYear := TextToInteger(COPYSTR(pText,1,4));
      IF (lDay = 0) OR (lMonth = 0) OR (lYear = 0) OR (lYear < 1754) THEN BEGIN
        EXIT;
      END;
      CASE lMonth OF
        1,3,5,7,8,10,12 : IF lDay > 31 THEN EXIT;
        4,6,9,11 : IF lDay > 30 THEN EXIT;
        2 :
          IF (lYear MOD 4) = 0 THEN BEGIN
            IF lDay > 29 THEN
              EXIT;
          END ELSE BEGIN
            IF lDay > 28 THEN
              EXIT;
          END;
        ELSE EXIT;
      END; // CASE

      rValue := DMY2DATE(lDay,lMonth,lYear);
      //>>IMH08.ISAT.EBA
    END;

    PROCEDURE ReplaceAccent@1100281014(pText@1100281000 : Text[1024]) : Text[1024];
    VAR
      lFromChar@1100281001 : Text[50];
      lToChar@1100281002 : Text[50];
    BEGIN
      //IMH12.ST
      lFromChar := '∑µ∂«éèÄ‘ê“”ﬁ÷◊ÿ„‡‚ÂôÎÈÍöÖ†É∆ÑÜáäÇàâç°åãï¢ì‰îó£ñÅ';
      lToChar := 'AAAAAACEEEEIIIIOOOOOUUUUaaaaaaceeeeiiiiooooouuuu';
      EXIT(CONVERTSTR(pText,lFromChar,lToChar));
    END;

    PROCEDURE GetSearchString@1100281015(pText@1100281000 : Text[1024]) rValue : Code[1024];
    VAR
      lFromChar@1100281002 : Text[80];
      lToChar@1100281001 : Text[80];
    BEGIN
      lFromChar:= '∑µ∂«éèÄ‘ê“”ﬁ÷◊ÿ„‡‚ÂôÎÈÍöÖ†É∆ÑÜáäÇàâç°åãï¢ì‰îó£ñÅ-,~''';
      lToChar :=  'AAAAAACEEEEIIIIOOOOOUUUUaaaaaaceeeeiiiiooooouuuu    ';
      EXIT(CONVERTSTR(pText,lFromChar,lToChar));
    END;

    PROCEDURE CheckPostCode@1100281016(pPostCode@1100281000 : Code[10];pCountryCode@1100281001 : Code[10];pText@1100281003 : Text[30]) : Boolean;
    VAR
      lPostCode@1100281002 : Record 225;
    BEGIN
      //IMH13
      IF pCountryCode <> '' THEN
        lPostCode.SETRANGE("Country/Region Code",pCountryCode);
      lPostCode.SETRANGE(Code,pPostCode);
      IF lPostCode.ISEMPTY THEN
        ERROR(STRSUBSTNO(Text003,pPostCode,pText));
    END;

    PROCEDURE EncodeBase64@1(VAR IStream@1000 : InStream;VAR OStream@1001 : OutStream);
    VAR
      inStr@1002 : Text[3];
      outStr@1003 : Text[4];
      iRead@1004 : Integer;
    BEGIN
      WHILE NOT IStream.EOS DO BEGIN
        iRead := IStream.READ(inStr[1],1);
        iRead += IStream.READ(inStr[2],1);
        iRead += IStream.READ(inStr[3],1);
        outStr := Encode_Byte(inStr[1] DIV 4);
        CASE iRead OF
          1:
            outStr :=
              outStr + Encode_Byte(((inStr[1] MOD 4) * 16)) + '==';
          2:
            outStr :=
              outStr + Encode_Byte(((inStr[1] MOD 4) * 16) + (inStr[2] DIV 16)) +
              Encode_Byte(((inStr[2] MOD 16) * 4)) + '=';
          3:
            outStr :=
              outStr + Encode_Byte(((inStr[1] MOD 4) * 16) + (inStr[2] DIV 16)) +
              Encode_Byte(((inStr[2] MOD 16) * 4) + (inStr[3] DIV 64)) + Encode_Byte(inStr[3]);
        END;
        OStream.WRITETEXT(outStr,4);
      END;
    END;

    LOCAL PROCEDURE Encode_Byte@2(b@1000 : Char) : Text[1];
    VAR
      Base64Code@1001 : TextConst 'ENU=ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    BEGIN
      EXIT(COPYSTR(Base64Code,(b MOD 64) + 1,1));
    END;

    PROCEDURE DecodeBase64@3(VAR IStream@1000 : InStream;VAR OStream@1001 : OutStream);
    VAR
      inStr@1002 : Text[4];
      InChar@1003 : ARRAY [4] OF Char;
      outStr@1004 : Text[1];
      EndFile@1005 : Boolean;
    BEGIN
      WHILE NOT IStream.EOS AND NOT EndFile DO BEGIN
        EndFile := TRUE;
        IF IStream.READ(inStr,4) = 4 THEN
          IF Decode_Byte(COPYSTR(inStr,1,1),InChar[1]) THEN
            IF Decode_Byte(COPYSTR(inStr,2,1),InChar[2]) THEN
              IF Decode_Byte(COPYSTR(inStr,3,1),InChar[3]) THEN
                IF Decode_Byte(COPYSTR(inStr,4,1),InChar[4]) THEN BEGIN
                  outStr[1] := (InChar[1] * 4) + (InChar[2] DIV 16);
                  OStream.WRITE(outStr[1],1);
                  IF InChar[3] <> 64 THEN BEGIN
                    outStr[1] := ((InChar[2] MOD 16) * 16) + (InChar[3] DIV 4);
                    OStream.WRITE(outStr[1],1);
                    IF InChar[4] <> 64 THEN BEGIN
                      outStr[1] := ((InChar[3] MOD 4) * 64) + InChar[4];
                      OStream.WRITE(outStr[1],1);
                      EndFile := FALSE;
                    END;
                  END;
                END;
      END;
    END;

    LOCAL PROCEDURE Decode_Byte@4(b@1000 : Text[1];VAR c@1001 : Char) : Boolean;
    VAR
      Base64Code@1002 : TextConst 'ENU="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="';
    BEGIN
      c := STRPOS(Base64Code,b);
      IF c <> 0 THEN BEGIN
        c := c - 1;
        EXIT(TRUE);
      END;
    END;

    PROCEDURE ChangeSpecChar2@1100281017(pString@1100281000 : Text[250]) : Text[250];
    VAR
      lToolsMgt@1100281005 : Codeunit 8016602;
      lFromChar@1100281001 : Text[100];
      lToChar@1100281004 : Text[100];
      i@1100281002 : Integer;
      lText001@1100281003 : TextConst 'ENU='';FRA=''';
    BEGIN
      //IMH07
      EXIT(lToolsMgt.ChangeSpecChar(pString, '1234567890'));
    END;

    PROCEDURE FormatImport2@1100281018(_Text@1000000000 : Text[1024]) : Text[1024];
    VAR
      i@1100281000 : Integer;
    BEGIN
      // Fonction de conserversion des caractäres de controles + FormatImport
      IF STRLEN(FromControlChar) = 0 THEN BEGIN
        FOR i := 1 TO 31 DO BEGIN
          FromControlChar[i] := i;
          ToControlChar += ' ';
        END;
      END;

      EXIT(CONVERTSTR(_Text, FromControlChar + GetAnsiStr, ToControlChar + GetAsciiStr));
    END;

    PROCEDURE ReplaceSpecialChar@1100281019(pText@1100281000 : Text[1024]) rValue : Text[1024];
    BEGIN
      // IMH14.PC
      rValue := CONVERTSTR(pText,'á','c');
    END;

    PROCEDURE ConvertString@1100281025(lOldStr@1100281000 : Text[1024];FromCharacters@1100281001 : Text[1024];ToCharacters@1100281002 : Text[1024];ConvertFirstFind@1100281003 : Boolean) rNewStr : Text[1024];
    VAR
      lPosFromCharac@1100281004 : Integer;
    BEGIN
      lPosFromCharac := STRPOS(lOldStr, FromCharacters);
      rNewStr := lOldStr;
      WHILE lPosFromCharac <> 0 DO BEGIN
        rNewStr := DELSTR(rNewStr, lPosFromCharac, STRLEN(FromCharacters));
        rNewStr := INSSTR(rNewStr, ToCharacters, lPosFromCharac);
        lPosFromCharac := STRPOS(rNewStr, FromCharacters);
        IF ConvertFirstFind THEN
          EXIT;
      END;
    END;

    PROCEDURE DecodeBase64File@1000000000(pFileName@1000000001 : Text[1024];pToFileName@1000000000 : Text[1024]) : Boolean;
    VAR
      lConvert@1000000002 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Convert";
      lStreamReader@1000000005 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.StreamReader";
      lString@1000000003 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.String";
      lTempGUID@1000000007 : GUID;
      lFile@1000000008 : DotNet "'mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.File";
    BEGIN
      lStreamReader := lStreamReader.StreamReader(pFileName, TRUE);
      lString := lConvert.FromBase64String(lStreamReader.ReadToEnd);
      lFile.WriteAllBytes(pToFileName,lString);
      lStreamReader.Close;
      lStreamReader.Dispose;
    END;

    BEGIN
    {
      /** @r IMH18 @d 25/04/14 @a ISAT.PC @v IMH6.01.P006 @s Interface GED
          @c Add new fonction TextToDatetime2 */
      /** @r IMH17 @d 24/04/13 @a ISAT.ML @v IMH6.01.343 @s Mantis avant TMA @h 4400 */
      /** @r IMH16 @d 24/09/12 @a ISAT.ZW @v IMH6.01.213 @s Projet SMS
          @c Ajout de la fonction ConvertString() */
      /** @r IMH15 @d 16/05/12 @a ISAT.ST @v IMH6.01.165 @s Extranet - Mantis
          @c Ajout fonctions GetEOL + TextToBoolean2 pour qualitÇ */
      /** @r IMH14 @d 27/04/12 @a ISAT.PC @v IMH6.01.165 @s Extranet - Mantis @h 2862 @c Ajout fonction ReplaceSpecialChar */
      /** @r IMH13 @d 13/09/11 @a ISAT.LLT @v IMH6.01.099 @s Ajout fonction controle CP */
      /** @r IMH12 @d 21/07/11 @a ISAT.ST @v IMH6.01.099 @s Divers @c Ajout ReplaceAccent */
      /** @r IMH11 @d 13/07/11 @a ISAT.PC @v IMH6.01.099 @s Divers @c ReplaceControlCaracter */
      /** @r IMH10 @d 05/07/11 @a ISAT.MA @v IMH6.01.099 @s Divers
          @c debug fct CheckCity */
      /** @r IMH09 @d 05/07/11 @a ISAT.PC @v IMH6.01.099 @s Divers
          @c Gestion nom de ville long */
      /** @r IMH08 @d 20/06/11 @a ISAT.EBA @v IMH6.01.133 @s Interface fichier sociÇtaire
          @c Ajout fonction "HasValue"
          @c Ajout fonction "TextToDate2" */
      /** @r IMH07 @d 08/05/2011 @a ISAT.ZW @V IMH6.01.132 @s Interface FUSION
          @c Ajout de la fonction CheckCity2() */
      /** @r IMH06 @d 16/05/2011 @a ISAT.MA @v IMH6.01.132 @s Interface DARVA
          @c Ajout de la fonction CheckCity() */
      /** @r IMH05 @d 04/05/2011 @a ISAT.PC @v IMH6.01.198 @s Reprise de donnÇes
          @c Modification de la fonction Ascii2Ansi : variable AnsiStr */
      /** @r IMH04 @d 17/12/2010 @a ISAT.ZW @v IMH6.01.002 @s Gestion des contacts
          @c Ajout de fontion de CalcDateTmeByFormula */
      /** @r IMH03 @d 08/12/2010 @a ISAT.LLT @v IMH6.01.002 @s Gestion des contacts
          @c Ajout de fontion de calcul de date */
      /** @r IMH02 @d 10/11/2010 @a ISAT.LLT @v IMH6.01.002 @s Gestion des contacts
          @c Ajout de la fonction GetCharNo */
      /** @r IMH01 @d 19/10/2010 @a ISAT.ZW @v IMH6.01.013 @s Gestion des actions
          @c Ajout Fonction GetAnsiStr +GetAsciiStr + FormatExport +FormatImport */
      /** @r ISA02 @d 01/06/10 @a ISAT.ST @v ISA6.00.00.01 @s Modifications
          @c DateToTextI56 renommÇ en DateToText2 (gäre date Ö vide)
          @c DateTimeToText, TextToDateTime **/

      /** @r ISA01 @d 07/07/09 @a ISAT.MA @v ISA6.00.00.01 @s Migration v6 **/
    }
    END.
  }
}